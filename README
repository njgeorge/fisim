This document describes the various steps for setup, and is meant to serve as a
HOWTO. Please contact the author Nishant George at nishant.george@gmail.com for
questions/comments/suggestions.

1. Prepare netlist
2. Generate parser
3. Run parser on netlist to create FI simulator
4. Run mutiple iterations, generate results
5. Gather results into readable form

1. Prepare netlist
The folder circuits/ contains several netlists that were synthesized using
Cadence RTL compiler. I'll use 4BitKSA as a working example for the rest of this
document. 4BitKSA.netlist is the output directly obtained from the RTL compiler
for a 4-bit Kogge Stone adder. 

There is a script called preprocess.pl in circuits/. If you look at this script,
you can see that it removes funny elements in the power and ground names, to
make parsing a little easier.

perl preprocess.pl <netlist> <preprocessed-netlist>

will prepare the netlist file for parsing. In circuits/ each netlist has been
preprocessed, and the netlists ready for parsing are suffixed with -ready.

2. Generate parser
Taking a look at the Makefile will reveal the various steps involved in
generating the parser. These are listed below.

a. yapp -m netlistparser 1-grammar.yp
b. perl 2-parse.pl
c. perl 3-backend.pl
d. vi 4-intermediate.code
e. perl 5-codegen.pl
f. grep Found 6-sim.pl
g. perl 9-makeiterator.pl

This tool uses Parse::Yapp, which stands for Yet Another Perl Parser compiler.
>yapp -V
This is Parse::Yapp version 1.05.

A number of steps happen in the background.

Before you run make, ensure that yapp extensions are installed for perl. Then
open up 2-perse.pl. Towards the beginning, you will be able to see which netlist
file is going to be parsed. The line corresponding to 4BitKSA will be
uncommented. Uncomment one line for each build, depending on which netlist is to
be put through the tool. Use a netlist file, which has be run through the
prepocessor circuits/preprocesor.pl.

When you run make, you can see that the intermediate file 4-intermediate code
will be opened for editing (step d). This is a manual step in which you have to
tell the tool which nets are considered output nets. This is not a step that I
was not able to automate easily because it is hard to determine from a list of
nets in the interface of a cell, which correspond to outputs. 

In this example, if you open up 4BitKSA-ready.netlist, at the very end, you can
infer from cell-definition that the output nets are called S_0 S_1 S_2 S_3 and
S_4 (carry) (line #278).

4BitKSA-ready.netlist
...
    275 // Library name: 4BitKSA
    276 // Cell name: UBKSA_3_0_3_0
    277 // View name: schematic
    278 U0 (S_4 S_3 S_2 S_1 S_0 X_3 X_2 X_1 X_0 Y_3 Y_2 Y_1 Y_0 gnd vdd) \
    279         UBPureKSA_3_0
...

At step d during the make process, in the text editor, you should
see something like the following.

--------- Beginning of 4-intermediatecode.pl -----------

# Intermediate code generated by backend.pl, forms intput for codegen.pl

# Inputs
X_0 X_1 X_2 X_3 Y_0 Y_1 Y_2 Y_3

# Please remove nets in the following line
# that are not considered output nets.
# Separate nets with whitespace. If none are removed,
# all non-input nets will be considered as output nets

# Noninputs
G0_1_U0_U0 G0_2_U0_U0 G0_3_U0_U0 G1_1_U0_U0 G1_2_U0_U0 G1_3_U0_U0 G_15_U0_U0
G_26_U0_U0 P0_1_U0_U0 P0_2_U0_U0 P0_3_U0_U0 P1_2_U0_U0 P1_3_U0_U0 S_0 S_1 S_2
S_3 S_4 n_0_U0_U0 n_0_U4_U0_U0 n_0_U7_U0_U0 n_0_U8_U0_U0 n_1_U0_U0 n_1_U5_U0_U0
n_1_U6_U0_U0 n_2_U0_U0

# Expressions
G0_3_U0_U0 = X_3 & Y_3
P0_3_U0_U0 = X_3 ^ Y_3
n_2_U0_U0 = ! P0_3_U0_U0
G0_2_U0_U0 = X_2 & Y_2
...

The parser should have identified the inupt nets correctly. Net names in the
noninputs section that are other than outputs have to be deleted. This manual
step is needed because the parser cannot identify from just the net names, which
correspond to outputs. The other items in the list are internal signals which
were automatically generated. So, remove all nets in the section Noninputs,
other than S_0 S_1 S_2 and S_3 S_4. Save and exit from vi (:wq). This should
continue the rest of the make process and you should see the following messages.

> make
yapp -m netlistparser 1-grammar.yp
32 shift/reduce conflicts and 1 reduce/reduce conflict
perl 2-parse.pl
Syntax is correct.
perl 3-backend.pl
Intermediate code written into 4-intermediate.code
vi 4-intermediate.code
perl 5-codegen.pl
Code generated into 6-sim.pl. Use 7-iterate.pl to run a campaign. Stats
collected in 8-stats-<loc>.txt
grep Found 6-sim.pl
# Fault Injection Section: Found 26 possible regions to inject
perl 9-makeiterator.pl
Usage: perl 9-makeiterator.pl <number of iterations> <number of FI locations>.
Use grep Found 6-sim.pl to determine second argument

6-sim.pl is the actual 'executable' simulator. When executed once, it simulates
one operation going through the logic circuit with random inputs and one fault
injection at a random location. 7-iterate.pl takes two arguments. Number of
fault injection runs, and the location to inject the fault. As per 6-sim.pl, you
can see that 26 possible locations were identified. 

>perl 7-iterate.pl 100 3
will run 100 fault injections are location 3. Random inputs are chosen for each
run.

The script 9-makeiterator.pl creates an iterator that runs fault injections over
any number of locations. e.g. 
>perl 9-makeiterator 100 5 
will create an iterator called 10-iterateall.pl, which 
when run, will run 100 fault injections on each of the first 6 locations. In
this case you want to run 
>perl 9-makeiterator 100 26
as per the messages from make, in order to cover all locations. 

Then you can run 
>perl 10-iterateall.pl
to start a campaign on all locations. 

Results will be in the folder called 8-results. There will be as many files in
this folder as the number of fault injection locations, in this case 26. They 
will be numbered stats-xx.txt. Each file will have as many lines as the number 
of fault injections performed on each location, in this case 100. E.g.

      1 S_3 S_4 
      2 unACE
      3 S_3 
      4 S_3 
      5 unACE
      6 S_3 
      7 S_3 S_4 
      ...

Each line shows a list of nets which had a bit-flip during that particular run.
Each time a campaign is run this file will look different because random inputs
are chosen. When there was no impact of fault, and the ouput matches the golden
fault free run, unACE appears.

11-gatherresults.pl parses all the stats files in 8-results/ and creates a
readable output like thus.

0000 85
0001 100
0002 70
0003 70
0004 100
0005 100
0006 100
...

Each number correpsonds to the following fraction for each location where faults
were injected.

# faulty runs/ # clean runs %

The output nets are not chosen for fault injection as a bit-flip on an output
bit is always ACE. The leading locations in the list of locations are the
inputs. e.g. in the list of 26, the first 8 will be the inputs.

>make clean 
can be used to remove all intermediate files and results for a clean slate.

Please contact Nishant George at nishant.george@gmail.com for
questions/suggestions. 
